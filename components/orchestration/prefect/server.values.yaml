## Server Deployment Configuration
server:
  # ref: https://docs.prefect.io/v3/develop/settings-and-profiles#security-settings
  basicAuth:
    # -- enable basic auth for the server, for an administrator/password combination
    enabled: true
    # -- basic auth credentials in the format admin:<your-password> (no brackets)
    authString: "admin:pass"
    # -- name of existing secret containing basic auth credentials. takes precedence over authString. must contain a key `auth-string` with the value of the auth string
    existingSecret: ""

  # ref: https://kubernetes.io/docs/concepts/scheduling-eviction/pod-priority-preemption/#priorityclass
  # -- priority class name to use for the server pods; if the priority class is empty or doesn't exist, the server pods are scheduled without a priority class
  priorityClassName: ""

  # ref: https://docs.prefect.io/v3/develop/settings-ref#base-path
  # -- sets PREFECT_SERVER_API_BASE_PATH
  apiBasePath: "/api"

  # ref: https://docs.prefect.io/v3/develop/settings-ref#debug-mode
  # -- sets PREFECT_DEBUG_MODE
  debug: false

  # ref: https://docs.prefect.io/v3/develop/settings-ref#logging-level-2
  # -- sets PREFECT_LOGGING_SERVER_LEVEL
  loggingLevel: WARNING

  uiConfig:
    # -- sets PREFECT_UI_API_URL; If you want to connect to the UI from somewhere external to the cluster (i.e. via an ingress), you need to set this value to the ingress URL (e.g. http://app.internal.prefect.com/api). You can find additional documentation on this here - https://docs.prefect.io/v3/manage/self-host#ui
    prefectUiApiUrl: "https://prefect.127.0.0.1.nip.io:8443/api"
    # -- sets PREFECT_UI_STATIC_DIRECTORY
    prefectUiStaticDirectory: "/ui_build"

  # see here for a full list of possible environment variables - https://docs.prefect.io/v3/develop/settings-ref#serversettings
  # -- array with environment variables to add to server deployment
  env: []
  ## env:
  ##   - name: PREFECT_API_ENABLE_HTTP2
  ##     value: false

  # -- Custom container command arguments
  args: []

  # -- Custom container entrypoint
  command: []

  # -- the number of old ReplicaSets to retain to allow rollback
  revisionHistoryLimit: 10

  # Autoscaling configuration
  # requests MUST be specified if using an HPA, otherwise the HPA will not know when to trigger a scale event
  autoscaling:
    # -- enable autoscaling for server
    enabled: false
    # -- minimum number of server replicas
    minReplicas: 1
    # -- maximum number of server replicas
    maxReplicas: 100
    # -- target CPU utilization percentage
    targetCPU: 80
    # -- target Memory utilization percentage
    targetMemory: 80

  # -- number of server replicas to deploy
  replicaCount: 1

  # requests MUST be specified if using an HPA, otherwise the HPA will not know when to trigger a scale event
  resources:
    # -- the requested resources for the server container
    requests:
      cpu: 500m
      memory: 512Mi
      # ephemeral-storage:
    # -- the requested limits for the server container
    limits:
      cpu: "1"
      memory: 1Gi
      # ephemeral-storage:

  # ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/
  livenessProbe:
    enabled: false
    config:
      # -- The number of seconds to wait before starting the first probe.
      initialDelaySeconds: 10
      # -- The number of seconds to wait between consecutive probes.
      periodSeconds: 10
      # -- The number of seconds to wait for a probe response before considering it as failed.
      timeoutSeconds: 5
      # -- The number of consecutive failures allowed before considering the probe as failed.
      failureThreshold: 3
      # -- The minimum consecutive successes required to consider the probe successful.
      successThreshold: 1
  readinessProbe:
    enabled: false
    config:
      # -- The number of seconds to wait before starting the first probe.
      initialDelaySeconds: 10
      # -- The number of seconds to wait between consecutive probes.
      periodSeconds: 10
      # -- The number of seconds to wait for a probe response before considering it as failed.
      timeoutSeconds: 5
      # -- The number of consecutive failures allowed before considering the probe as failed.
      failureThreshold: 3
      # -- The minimum consecutive successes required to consider the probe successful.
      successThreshold: 1

  # ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-pod
  podSecurityContext:
    # -- set server pod's security context runAsUser
    runAsUser: 1001
    # -- set server pod's security context runAsNonRoot
    runAsNonRoot: true
    # -- set server pod's security context fsGroup
    fsGroup: 1001
    # -- set server pod's seccomp profile
    seccompProfile:
      type: RuntimeDefault
      # -- in case of Localhost value in seccompProfile.type, set seccompProfile.localhostProfile value below
      # localhostProfile: /my-path.json

  # ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-container
  containerSecurityContext:
    # -- set server containers' security context runAsUser
    runAsUser: 1001
    # -- set server containers' security context runAsNonRoot
    runAsNonRoot: true
    # -- set server containers' security context readOnlyRootFilesystem
    readOnlyRootFilesystem: true
    # -- set server containers' security context allowPrivilegeEscalation
    allowPrivilegeEscalation: false
    # -- set server container's security context capabilities
    capabilities: {}

  # ref: https://kubernetes.io/docs/concepts/workloads/controllers/deployment/
  # -- Specifies the strategy used to replace old Pods by new ones. Type can be "Recreate" or "RollingUpdate".
  # Setting this to "Recreate" is useful when database is on a mounted volume that can only be attached to a single node at a time.
  updateStrategy:
    type: RollingUpdate
    # example RollingUpdate options
    # rollingUpdate:
    #   maxUnavailable: "1"
    #   maxSurge: "25%"

## Background Services Deployment Configuration
backgroundServices:
  # ref: https://github.com/PrefectHQ/prefect/tree/main/src/prefect/server/services
  # This can help with:
  # - Separate scaling of web server and background services
  # - Independent connection pools for better database management
  # - More granular monitoring and resource control
  # - Run background services (like scheduling) in a separate deployment.
  runAsSeparateDeployment: false

  # ref: https://kubernetes.io/docs/concepts/scheduling-eviction/pod-priority-preemption/#priorityclass
  # -- priority class name to use for the background-services pods; if the priority class is empty or doesn't exist, the background-services pods are scheduled without a priority class
  priorityClassName: ""

  # ref: https://docs.prefect.io/v3/develop/settings-ref#debug-mode
  # -- sets PREFECT_DEBUG_MODE
  debug: false

  # ref: https://docs.prefect.io/v3/develop/settings-ref#logging-level-2
  # -- sets PREFECT_LOGGING_SERVER_LEVEL
  loggingLevel: WARNING

  # see here for a full list of possible environment variables - https://docs.prefect.io/latest/api-ref/prefect/settings/
  # -- array with environment variables to add to background-services container
  env: []
  ## env:
  ##   - name: PREFECT_API_ENABLE_HTTP2
  ##     value: false

  # -- Custom container command arguments
  args: []

  # -- Custom container entrypoint
  command: []

  # -- the number of old ReplicaSets to retain to allow rollback
  revisionHistoryLimit: 10

  resources:
    # -- the requested resources for the background-services container
    requests:
      cpu: 500m
      memory: 512Mi
    # -- the requested limits for the background-services container
    limits:
      cpu: "1"
      memory: 1Gi

  # ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-pod
  podSecurityContext:
    # -- set background-services pod's security context runAsUser
    runAsUser: 1001
    # -- set background-services pod's security context runAsNonRoot
    runAsNonRoot: true
    # -- set background-services pod's security context fsGroup
    fsGroup: 1001

  # ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-container
  containerSecurityContext:
    # -- set background-services containers' security context runAsUser
    runAsUser: 1001
    # -- set background-services containers' security context runAsNonRoot
    runAsNonRoot: true
    # -- set background-services containers' security context readOnlyRootFilesystem
    readOnlyRootFilesystem: true
    # -- set background-services containers' security context allowPrivilegeEscalation
    allowPrivilegeEscalation: false
    # -- set background-services container's security context capabilities
    capabilities: {}

  # ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
  # -- extra labels for background-services pod
  podLabels: {}

  # ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
  # -- extra annotations for background-services pod
  podAnnotations: {}

  # ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity
  # -- affinity for background-services pod assignment
  affinity: {}

  # ref: https://kubernetes.io/docs/user-guide/node-selection/
  # -- node labels for background-services pod assignment
  nodeSelector: {}

  # ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
  # -- tolerations for background-services pod assignment
  tolerations: []

  # -- name of existing ConfigMap containing extra env vars to add to background-services pod
  extraEnvVarsCM: ""

  # -- name of existing Secret containing extra env vars to add to background-services pod
  extraEnvVarsSecret: ""

  # -- additional sidecar containers
  extraContainers: []

  # -- array with extra volumes for the background-services pod
  extraVolumes: []

  # -- array with extra volumeMounts for the background-services pod
  extraVolumeMounts: []

  ## Background Services Service Account configuration
  serviceAccount:
    # -- specifies whether a service account should be created
    create: true
    # -- the name of the service account to use. if not set and create is true, a name is generated using the common.names.fullname template with "-background-services" appended
    name: ""
    # -- additional service account annotations (evaluated as a template)
    annotations: {}

  # Configuration for background service messaging using Redis
  messaging:
    # ref: https://docs.prefect.io/v3/api-ref/settings-ref#messaging-broker
    # -- messaging broker class to use for background services
    broker: prefect_redis.messaging

    # ref: https://docs.prefect.io/v3/api-ref/settings-ref#messaging-cache
    # -- messaging cache class to use for background services
    cache: prefect_redis.messaging

    # -- settings for redis broker/cache
    # change these if not using the built-in redis subchart
    redis:
      # -- redis hostname
      # if using the built-in redis subchart, this will be automatically set to the redis subchart's service name
      host: ""

      # -- redis port
      port: 6379

      # -- redis database number
      db: 0

      # -- redis username, leave empty to use no authentication
      # if using the built-in redis subchart, this will be automatically set to the redis subchart's username value
      username: ""

      # -- redis password, leave empty to use default
      # if using the built-in redis subchart, this will be automatically set to the redis subchart's password value
      password: ""

      # -- use TLS for redis connection
      ssl: false

## Server Service Account configuration
serviceAccount:
  # -- specifies whether a service account should be created
  create: true
  # -- the name of the service account to use. if not set and create is true, a name is generated using the common.names.fullname template
  name: ""
  # -- additional service account annotations (evaluated as a template)
  annotations: {}

## Service configuration
service:
  # -- service port
  port: 4200
  # -- target port of the server pod; also sets PREFECT_SERVER_API_PORT
  targetPort: 4200
  # -- service port if defining service as type nodeport
  nodePort: ""

  extraPorts: []
  # example extra ports
  # - name: sample-svc-port
  #   # -- service port
  #   port: 8080
  #   # -- target port
  #   targetPort: 8080
  #   # -- service port if defining service as type nodeport
  #   nodePort: ""

  # -- service type
  type: ClusterIP
  # -- service Cluster IP
  clusterIP: ""

  # ref: http://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/#preserving-the-client-source-ip
  # -- service external traffic policy
  externalTrafficPolicy: Cluster
  # -- additional custom annotations for server service
  annotations: {}

# Disable Ingress (Gateway and Ingress are mutually exclusive)
ingress:
  enabled: false

# Enable and configure Gateway API
gateway:
  enabled: true

  # Use 'cilium' GatewayClass
  className: "cilium"
  # This tells the 'ca-issuer' to automatically create a certificate
  annotations:
    cert-manager.io/cluster-issuer: "ca-cluster-issuer"

  listeners:
    - name: http
      port: 8080
      protocol: HTTP
      hostname: "prefect.127.0.0.1.nip.io"
    - name: https
      port: 8443
      protocol: HTTPS
      hostname: "prefect.127.0.0.1.nip.io"
      tls:
        mode: Terminate
        certificateRefs:
          - name: "prefect-tls-secret"

httproute:
  enabled: true
  hostnames:
    - "prefect.127.0.0.1.nip.io"
  parentRefs:
    - sectionName: https
  tls:
    redirect: true
    redirectPort: 8443

# Secret configuration
secret:
  # -- whether to create a Secret containing the PostgreSQL connection string
  create: true
  # -- name for the Secret containing the PostgreSQL connection string
  # To provide an existing Secret, provide a name and set `create=false`
  name: ""
  # -- username for the PostgreSQL connection string
  username: ""
  # -- password for the PostgreSQL connection string
  password: ""
  # -- host for the PostgreSQL connection string
  host: ""
  # -- port for the PostgreSQL connection string
  port: ""
  # -- database for the PostgreSQL connection string
  database: ""

# SQLite configuration
# Recommended for lightweight, single-server deployments.
sqlite:
  # -- enable use of the embedded SQLite database
  enabled: true

  persistence:
    # -- enable SQLite data persistence using PVC
    enabled: true
    # -- size for the PVC
    size: 1Gi
    # -- storage class name for the PVC
    storageClassName: ""

postgresql:
  # -- enable use of the built-in PostgreSQL subchart
  enabled: false

# Redis subchart - default overrides
redis:
  # -- enable use of bitnami/redis subchart
  # if backgroundServices.runAsSeparateDeployment=true, you must set this to true or provide your own redis instance
  enabled: true

  # -- Redis architecture
  # Note: Prefect currently only supports standalone Redis deployments.
  architecture: standalone

  image:
    # -- Image repository.  Defaults to legacy bitnami repository for redis 8.2.1 availability.
    repository: bitnamilegacy/redis
    # -- Version tag, corresponds to tags at https://hub.docker.com/r/bitnami/redis/
    tag: 8.2.1
