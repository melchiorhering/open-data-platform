## @section Redis image parameters
image:
  ## @param image.registry Redis image registry
  registry: docker.io
  ## @param image.repository Redis image repository
  repository: redis
  ## @param image.tag Redis image tag
  tag: "8.2.3@sha256:5c7c0445ed86918cb9efb96d95a6bfc03ed2059fe2c5f02b4d74f477ffe47915"
  ## @param image.pullPolicy Redis image pull policy
  pullPolicy: Always

## @section Redis Architecture
## @param architecture Redis architecture. Allowed values: standalone, replication
## - standalone: Single Redis instance
## - replication: Master-replica setup (use sentinel.enabled to enable/disable Sentinel)
## - cluster: Multi-master setup with optional replicas
architecture: standalone

## @param replicaCount Number of Redis instances to deploy (only when architecture=(replication|cluster))
## When using architecture=replication:
##   with Sentinel, this is the total number of Redis instances (including the initial master)
##   without Sentinel, pod-0 is always the master and other pods are replicas
##   For example: replicaCount: 3 creates 1 master + 2 replicas
## When using architecture=cluster:
##   this is total number of nodes, including replicas
##   Value should be a multiple of (clusterReplicaCount + 1) and not less than 3
replicaCount: 1

## @param clusterReplicaCount Number of replicas for each master node when architecture=cluster.
## For example: replicaCount: 6 and clusterReplicaCount: 1 creates 3 masters + 3 replicas (1 per master)
clusterReplicaCount: 0

## @section Pod labels and annotations
## @param podLabels Map of labels to add to the pods
podLabels: {}
## @param podAnnotations Map of annotations to add to the pods
podAnnotations: {}

## @param ipFamily IP family to use for replica and sentinel announce IPs. Allowed values: auto, ipv4, ipv6
## auto: Uses the first IP returned by hostname -i (default)
## ipv4: Forces IPv4 address selection
## ipv6: Forces IPv6 address selection
ipFamily: auto

service:
  ## @param service.annotations Additional custom annotations for Redis service
  annotations: {}
  ## @param service.type Kubernetes service type
  type: ClusterIP
  ## @param service.port Redis service port
  port: 6379
  ## @param service.clusterPort Redis cluster port. Applicable only if architecture=cluster
  clusterPort: 16379
  headless:
    ## @param service.headless.annotations Additional custom annotations for Redis headless service
    annotations: {}

auth:
  ## @param auth.enabled Enable Redis authentication
  enabled: true
  ## @param auth.enabled Enable Sentinel authentication
  sentinel: true
  ## @param auth.password Redis password (if empty, random password will be generated)
  password: ""
  ## @param auth.existingSecret Name of existing secret containing Redis password
  existingSecret: ""
  ## @param auth.existingSecretPasswordKey Key in existing secret containing Redis password
  existingSecretPasswordKey: ""

## @section config Redis configuration options
config:
  ## @param config.mountPath Redis configuration options
  mountPath: /usr/local/etc/redis
  ## @param config.content Include your custom Redis configurations here as string
  ## If no config is provided, minimal config will be created on the fly
  content: |
    # Redis configuration
    bind * -::*
    port 6379
  ## param config.existingConfigmap Name of an existing Configmap to use instead of creating one
  existingConfigmap: ""
  ## param config.existingConfigmapKey Name of the key in the Configmap that should be used
  existingConfigmapKey: ""

## @Section Pod Disruption Budget
pdb:
  ## @param pdb.enabled Enable Pod Disruption Budget
  enabled: false
  ## @param pdb.minAvailable Minimum number/percentage of pods that should remain scheduled
  minAvailable: 1
  ## @param pdb.maxUnavailable Maximum number/percentage of pods that may be made unavailable
  maxUnavailable: ""

persistence:
  ## @param persistence.enabled Enable persistent storage
  enabled: true
  ## @param persistence.storageClass Storage class to use for persistent volume
  storageClass: ""
  ## @param persistence.accessMode Access mode for persistent volume
  accessMode: ReadWriteOnce
  ## @param persistence.size Size of persistent volume
  size: 8Gi
  ## @param persistence.mountPath Mount path for Redis data
  mountPath: /data
  ## @param persistence.annotations Annotations for persistent volume claims
  annotations: {}

## @section Persistent Volume Claim Retention Policy
persistentVolumeClaimRetentionPolicy:
  ## @param persistentVolumeClaimRetentionPolicy.enabled Enable Persistent volume retention policy for the Statefulset
  enabled: false
  ## @param persistentVolumeClaimRetentionPolicy.whenScaled Volume retention behavior when the replica count of the StatefulSet is reduced
  whenScaled: Retain
  ## @param persistentVolumeClaimRetentionPolicy.whenDeleted Volume retention behavior that applies when the StatefulSet is deleted
  whenDeleted: Retain

## @param resources Resource limits and requests for Redis pod
resources:
  limits:
    memory: 128Mi
  requests:
    cpu: 50m
    memory: 128Mi

## @param nodeSelector Node selector for pod assignment
nodeSelector: {}

## @param priorityClassName for pod eviction
priorityClassName: ""

## @param tolerations Tolerations for pod assignment
tolerations: []

## @param affinity Affinity rules for pod assignment
affinity: {}

## @param topologySpreadConstraints Topology Spread Constraints for pod assignment
topologySpreadConstraints: []

containerSecurityContext:
  ## @param containerSecurityContext.runAsUser User ID to run the container
  runAsUser: 999
  ## @param containerSecurityContext.runAsGroup Group ID to run the container
  runAsGroup: 999
  ## @param containerSecurityContext.runAsNonRoot Run as non-root user
  runAsNonRoot: true
  ## @param containerSecurityContext.privileged Set container's privileged mode
  privileged: false
  ## @param containerSecurityContext.allowPrivilegeEscalation Set Redis container's privilege escalation
  allowPrivilegeEscalation: false
  ## @param containerSecurityContext.readOnlyRootFilesystem Read-only root filesystem
  readOnlyRootFilesystem: true
  ## @param containerSecurityContext.capabilities Linux capabilities to be dropped
  capabilities:
    drop:
      - ALL
  ## @param containerSecurityContext.seccompProfile Seccomp profile for the container
  seccompProfile:
    type: RuntimeDefault

## @param podSecurityContext Security context for the pod
podSecurityContext:
  ## @param podSecurityContext.fsGroup Set Redis pod's Security Context fsGroup
  fsGroup: 999

livenessProbe:
  ## @param livenessProbe.enabled Enable liveness probe
  enabled: true
  ## @param livenessProbe.initialDelaySeconds Initial delay before starting probes
  initialDelaySeconds: 30
  ## @param livenessProbe.periodSeconds How often to perform the probe
  periodSeconds: 10
  ## @param livenessProbe.timeoutSeconds Timeout for each probe attempt
  timeoutSeconds: 5
  ## @param livenessProbe.failureThreshold Number of failures before pod is restarted
  failureThreshold: 6
  ## @param livenessProbe.successThreshold Number of successes to mark probe as successful
  successThreshold: 1

readinessProbe:
  ## @param readinessProbe.enabled Enable readiness probe
  enabled: true
  ## @param readinessProbe.initialDelaySeconds Initial delay before starting probes
  initialDelaySeconds: 5
  ## @param readinessProbe.periodSeconds How often to perform the probe
  periodSeconds: 10
  ## @param readinessProbe.timeoutSeconds Timeout for each probe attempt
  timeoutSeconds: 5
  ## @param readinessProbe.failureThreshold Number of failures before pod is marked unready
  failureThreshold: 6
  ## @param readinessProbe.successThreshold Number of successes to mark probe as successful
  successThreshold: 1

startupProbe:
  ## @param startupProbe.enabled Enable startup probe
  enabled: false
  ## @param startupProbe.initialDelaySeconds Initial delay before starting probes
  initialDelaySeconds: 10
  ## @param startupProbe.periodSeconds How often to perform the probe
  periodSeconds: 10
  ## @param startupProbe.timeoutSeconds Timeout for each probe attempt
  timeoutSeconds: 5
  ## @param startupProbe.failureThreshold Number of failures before pod is restarted (30 * 10s = 5 minutes)
  failureThreshold: 30
  ## @param startupProbe.successThreshold Number of successes to mark probe as successful
  successThreshold: 1

## @param extraEnvVars Additional environment variables to set
extraEnvVars:
  []
  # - name: CUSTOM_VAR
  #   value: "custom-value"
  # - name: SECRET_VAR
  #   valueFrom:
  #     secretKeyRef:
  #       name: my-secret
  #       key: secret-key

## @param extraFlags Additional command-line flags to pass to redis-server
## Example:
## extraFlags:
##   - --maxmemory 230mb
##   - --maxmemory-policy volatile-lru
extraFlags: []

## @param extraPorts Additional ports to add to the pod and service
## Example:
## extraPorts:
## - name: redis-cluster
##   port: 16379
##   targetPort: redis-cluster
##   containerPort: 16379
extraPorts: []

## @param extraVolumes Additional volumes to add to the pod
extraVolumes: []

## @param extraVolumeMounts Additional volume mounts to add to the Redis container
extraVolumeMounts: []

## @section Redis Sentinel configuration
## This section configures Redis Sentinel for high availability in replication mode
## When enabled, Redis instances use dynamic master/replica role assignment managed by Sentinel
## When disabled with replication architecture, pod-0 is always the master and other pods are replicas
sentinel:
  ## @param sentinel.enabled Enable Redis Sentinel for high availability
  ## IMPORTANT: When enabled, applications should use Sentinel-aware clients to discover the current master
  ## When disabled, pod-0 is the master and can be accessed via the -master service
  enabled: false
  ## @param sentinel.image.repository Redis Sentinel image repository
  image:
    repository: redis
    tag: "8.2.3@sha256:5c7c0445ed86918cb9efb96d95a6bfc03ed2059fe2c5f02b4d74f477ffe47915"
    pullPolicy: Always
  ## @param sentinel.masterName Name of the master server (default: mymaster)
  masterName: mymaster
  ## @param sentinel.quorum Number of Sentinels that need to agree about the fact the master is not reachable
  quorum: 2
  ## @param sentinel.downAfterMilliseconds Time in milliseconds after the master is declared down
  downAfterMilliseconds: 1500
  ## @param sentinel.failoverTimeout Timeout for failover in milliseconds
  failoverTimeout: 15000
  ## @param sentinel.parallelSyncs Number of replicas that can be reconfigured to use the new master during a failover
  parallelSyncs: 1
  ## @param sentinel.port Sentinel port
  port: 26379
  ## @param sentinel.extraVolumeMounts Additional volume mounts to add to the Sentinel container
  extraVolumeMounts: []
  service:
    ## @param sentinel.service.type Kubernetes service type for Sentinel
    type: ClusterIP
    ## @param sentinel.service.port Sentinel service port
    port: 26379
  ## @param sentinel.resources Resource limits and requests for Sentinel pods
  resources:
    limits:
      memory: 128Mi
    requests:
      cpu: 25m
      memory: 64Mi

## @param resources Resource limits and requests for Redis init container pod
initContainer:
  resources:
    limits:
      cpu: 50m
      memory: 128Mi
    requests:
      cpu: 25m
      memory: 64Mi

## @section Redis metrics parameters
## Prometheus metrics configuration
metrics:
  ## @param metrics.enabled Start a sidecar prometheus exporter to expose Redis metrics
  enabled: false
  ## @param metrics.image.registry Redis exporter image registry
  ## @param metrics.image.repository Redis exporter image repository
  ## @param metrics.image.tag Redis exporter image tag
  ## @param metrics.image.pullPolicy Redis exporter image pull policy
  image:
    registry: docker.io
    repository: oliver006/redis_exporter
    tag: "v1.80.0@sha256:cd5fad1591e585db5b58beec7fca427027c61a4349f50109af67cf2f07964d02"
    pullPolicy: Always
  ## @param metrics.resources Resource limits and requests for metrics container
  resources:
    limits:
      memory: 64Mi
    requests:
      cpu: 50m
      memory: 64Mi
  ## @param metrics.extraArgs Extra arguments for redis exporter, for example:
  ## extraArgs:
  ##   - --redis.addr=redis://localhost:6379
  ##   - --web.listen-address=0.0.0.0:9121
  extraArgs: []
  ## Metrics service configuration
  service:
    ## @param metrics.service.type Metrics service type
    type: ClusterIP
    ## @param metrics.service.port Metrics service port
    port: 9121
    ## @param metrics.service.annotations Additional custom annotations for Metrics service
    annotations: {}
    ## @param metrics.service.loadBalancerIP Load balancer IP if metrics service type is `LoadBalancer`
    loadBalancerIP: ""
    ## @param metrics.service.loadBalancerSourceRanges Addresses that are allowed when metrics service is LoadBalancer
    loadBalancerSourceRanges: []
    ## @param metrics.service.clusterIP Static clusterIP or None for headless services when metrics service type is ClusterIP
    clusterIP: ""
    ## @param metrics.service.nodePort Specify the nodePort value for the LoadBalancer and NodePort service types
    nodePort: ""
  ## Prometheus ServiceMonitor configuration
  serviceMonitor:
    ## @param metrics.serviceMonitor.enabled Create ServiceMonitor resource(s) for scraping metrics using PrometheusOperator
    enabled: false
    ## @param metrics.serviceMonitor.namespace Namespace in which to create ServiceMonitor resource(s)
    namespace: ""
    ## @param metrics.serviceMonitor.interval Interval at which metrics should be scraped
    interval: 30s
    ## @param metrics.serviceMonitor.scrapeTimeout Timeout after which the scrape is ended
    scrapeTimeout: ""
    ## @param metrics.serviceMonitor.relabelings Specify additional relabeling of metrics
    relabelings: []
    ## @param metrics.serviceMonitor.metricRelabelings Specify additional metric relabeling of metrics
    metricRelabelings: []
    ## @param metrics.serviceMonitor.honorLabels Honor metrics labels
    honorLabels: false
    ## @param metrics.serviceMonitor.selector Prometheus instance selector labels
    selector: {}
    ## @param metrics.serviceMonitor.annotations Additional custom annotations for the ServiceMonitor
    annotations: {}
    ## @param metrics.serviceMonitor.namespaceSelector Namespace selector for ServiceMonitor
    namespaceSelector: {}

## @section Network Policy
networkPolicy:
  ## @param networkPolicy.enabled Enable NetworkPolicy
  enabled: false
  ## @param networkPolicy.allowExternal Allow external traffic
  allowExternal: true
  ## @param networkPolicy.extraIngress Additional ingress rules
  extraIngress: []
  ## @param networkPolicy.extraEgress Additional egress rules
  extraEgress: []

## @param extraObjects Array of extra objects to deploy with the release
extraObjects: []
# - apiVersion: v1
#   kind: ConfigMap
#   metadata:
#     name: extra-config
#     namespace: "{{ include "common.namespace" . }}"
#   data:
#     key: value

## @section Custom Scripts and Hooks
customScripts:
  ## @param customScripts.postStart PostStart lifecycle hook configuration
  postStart:
    ## @param customScripts.postStart.enabled Enable postStart lifecycle hook
    enabled: false
    ## @param customScripts.postStart.command Command to execute in postStart hook
    command: []
    # Example:
    # - /bin/bash
    # - -c
    # - |
    #   sleep 5
    #   echo "Redis started"
  ## @param customScripts.preStop PreStop lifecycle hook configuration
  preStop:
    ## @param customScripts.preStop.enabled Enable preStop lifecycle hook
    ## NOTE: When enabled, this overrides the default preStop hook used by Sentinel
    enabled: false
    ## @param customScripts.preStop.command Command to execute in preStop hook
    command: []
    # Example:
    # - /bin/bash
    # - -c
    # - |
    #   sleep 10
    #   redis-cli shutdown
